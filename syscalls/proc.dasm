; PROC_EXIT (0xf010)
; terminates the current (calling) process
:_proc_exit
	SET PEEK, [_tasking_current_pid] ; Current Process ID
	SET PC, _proc_kill

; PROC_GETID (0xf011)
; returns pid of the calling process (A)
:_proc_getid
	SET PEEK, [_tasking_current_pid] ; directly set [SP] (stored A)
	RFI 0

; PROC_FORK (0xf012)
; copies the calling process. returns the child pid in the main, 0 in the child process
:_proc_fork
	; allocate new memory in current process size
	; copy process
	; duplicate entry in processes
	; set A to 0 in child register entries
	ADD SP, 1
	; A: Child Pid
	SET PC, POP

; PROC_KILL (0xf013)
; terminates process with pid in A
:_proc_kill
	SET A, POP
	; free process' dynamically allocated memory
	; remove from multitasking list:
	SET Y, [_tasking_current_task]
:.loop
	SET X, Y
	SET Y, [X+1] ; go one step further
	IFN [Y], A ; not the one we search for
		SET PC, .loop
	SET [X+1], [Y+1] ; Y is the one to delete, so set the parent's successor to [Y+1]
	SET A, Y ; free the task info
	JSR _mem_alloc_memory 		
	SET PC, POP

; PROC_EXEC (0xf014)
; creates a new process from the memory at A, returns pid in A
:_proc_exec
	SET A, POP
	; dis-own memory at A
	; add entry in process table
	SET A, 0 ; new pid
	SET PC, POP

; PROC_SKIP (0xf015)
; skips current process / slice (give other processes more time)
; is directly mapped to _tasking_next_slice, see handler.dasm